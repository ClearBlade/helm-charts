{{- if eq .Values.global.secretManager "gsm" }}
apiVersion: batch/v1
kind: Job
metadata:
  name: tls-secret-job
  namespace: {{ default "clearblade" .Values.global.namespace }}
  labels:
    app: tls-secret-job
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-weight": "1"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  template:
    metadata:
      labels:
        app: tls-secret-job
    spec:
      serviceAccountName: clearblade-gsm-read
      restartPolicy: OnFailure
      containers:
        - name: tls-secret-creator
          image: google/cloud-sdk:slim
          command: ["/bin/bash"]
          args:
            - -c
            - |
              set -ex
              # Install kubectl and openssl
              apt-get update && apt-get install -y kubectl openssl
              
              # Fetch certificate from GSM
              certificate=$(gcloud secrets versions access latest --secret={{ default "clearblade" .Values.global.namespace }}_tls-certificates)
              
              # Create temporary file
              echo "$certificate" > /tmp/full_cert.pem
              
              echo "==== DEBUG: Processing PEM file ===="
              
              # Split the PEM file into individual certificates and keys
              csplit -sz -f /tmp/cert- /tmp/full_cert.pem '/-----BEGIN CERTIFICATE-----/' '{*}'
              csplit -sz -f /tmp/key- /tmp/full_cert.pem '/-----BEGIN PRIVATE KEY-----/' '{*}'
              
              # Find the first RSA certificate
              found_cert=0
              for certfile in /tmp/cert-*; do
                if [ -s "$certfile" ]; then
                  echo "Checking certificate: $certfile"
                  if openssl x509 -in "$certfile" -text -noout 2>/dev/null | grep -q "Public Key Algorithm: rsaEncryption"; then
                    cp "$certfile" /tmp/cert.pem
                    found_cert=1
                    echo "==== DEBUG: Found first RSA certificate: $certfile ===="
                    break
                  fi
                fi
              done
              
              if [ $found_cert -eq 0 ]; then
                echo "==== DEBUG: No RSA certificate found ===="
                exit 1
              fi
              
              # Find the first RSA private key
              found_key=0
              for keyfile in /tmp/key-*; do
                if [ -s "$keyfile" ]; then
                  echo "Checking private key: $keyfile"
                  # Try to parse as RSA key
                  if openssl rsa -in "$keyfile" -check -noout 2>/dev/null; then
                    cp "$keyfile" /tmp/key.pem
                    found_key=1
                    echo "==== DEBUG: Found first RSA private key: $keyfile ===="
                    break
                  fi
                fi
              done
              
              if [ $found_key -eq 0 ]; then
                echo "==== DEBUG: No RSA private key found ===="
                exit 1
              fi
              
              # Check that both files exist and are not empty
              if [ -s /tmp/cert.pem ] && [ -s /tmp/key.pem ]; then
                kubectl create secret tls tls-secret \
                  --cert=/tmp/cert.pem \
                  --key=/tmp/key.pem \
                  --dry-run=client -o yaml | kubectl apply -f -
                echo "TLS secret created/updated successfully"
              else
                echo "Failed to extract RSA certificate or key from .pem file"
                exit 1
              fi
{{- end }} 